% |--- Preâmbulo ---|----------------------{{{
\documentclass[a4paper, 12 pt]{article} % Article são textos pequenos
%\documentclass[a4paper, 12 pt]{report} % Topologia para relatórios
%\documentclass[a4paper, 12 pt]{book} % Livros e Apostilas 
%\documentclass[a4paper, 12 pt]{letter} % Cartas

% |--- Pacotes ---|----------------------{{{

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry} % Margens da Página
\usepackage[utf8]{inputenc} % Codificação do Texto
\usepackage{amsmath, mathrsfs, amsfonts, amssymb, esvect} % Pacotes de Matemática
\usepackage{graphicx} % Inserir Figuras, gráficos
\usepackage{float} % Inserir figuras: posicionamento
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel} % Para mudar os nomes padrões de comandos
\usepackage{indentfirst} % Sempre identar o 1º parágrafo
\usepackage{ccaption} % Formatas caps de figuras, tabelas
\usepackage{setspace} % Espaçamento Entre Linhas
\usepackage{multicol, multirow} % Mesclar colunas e linhas tabela
\usepackage{fancyhdr} % Personalizar Cabeçalho e Rodapé
\usepackage{enumerate} % Enumerar as páginas
\usepackage{longtable} % Habilitar tabela que é maior que uma página
\usepackage{setspace} % Setar funções de espaço
\usepackage{scalefnt} % Comando \scalefont
\usepackage[final]{pdfpages} % Colocar algum PDF como fundo de página
\usepackage{color, colortbl} % Para usar cor no texto
\usepackage{float}
\usepackage{ifthen}
\usepackage{scalefnt}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{subfigure}
\usepackage{enumerate}
\usepackage{caption}
\usepackage[sort,compress]{cite}
\usepackage{natbib} 
\usepackage{booktabs}
\usepackage{comment}
\usepackage{tocbibind}
\usepackage{xcolor}
\usepackage{blindtext}
\usepackage{listings}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{blue},
  keywordstyle=\color{red},
  breaklines=true
}


\renewcommand{\figurename}{Figura}
\renewcommand{\tablename}{Tabela}
\renewcommand{\refname}{Referências}
\newcommand{\sen}{\mathop{\rm sen}}

% Pacotes de Fontes
\usepackage[T1]{fontenc} % Permite que o LaTeX compreenda a acentuação feita direto pelo teclado. É usado com o opcional [T1].
\usepackage{calligra}


\usepackage{color}
\usepackage[normalem]{ulem}
\definecolor{darkgreen}{RGB}{0,80,0}

\newcommand{\old}[1]{{\color{red}\sout{#1}}}
\newcommand{\new}[1]{{\color{blue}#1}}
\newcommand{\commentS}[1]{{\color{darkgreen}{\bfseries [#1]}}}


\title{Trabalho Final}
\author{Danilo Portela de Oliveira \\ danilo.portela@aluno.unb.br}
\date{2022}

\begin{document}

%%%%%%%%%%%CAPA%%%%%%%%%%%%%%%%%%%
	
\thispagestyle{empty}
%\includepdf[pages=1, scale=1.0, frame=false, offset = 0 00, pagecommand={\vspace*{95mm}}]{capa} %% Página Sozinha

\includepdf[pages=1, scale=1.0, frame=false, offset = 0 00, pagecommand=
{\vspace*{35mm}
	\begin{center}
		\scalebox{1.1}{\sffamily{Universidade de Brasília}}\\
		\scalebox{1.1}{\sffamily{Instituto de Geociências - IG}}\\
		%\scalebox{1.1}{\sffamily{Curso}}
		[45pt]
		\scalebox{1.2}{\sffamily{\textbf{Desenvolvimento de metodologia de tomografia sísmica}} }\\[05pt]
		\scalebox{1.2}{\sffamily{\textbf{para aplicações rasas}} }\\[05pt]
		\scalebox{1.2}{ }\\[+35pt]
		\scalebox{1}{Danilo Portela de Oliveira\hspace{05pt}}\\
		\scalebox{1}{}\\[-07pt]
		\scalebox{1}{}\\[20pt]
		\scalebox{1}{Orientador: Marcelo Peres Rocha}\\[10pt]
		\scalebox{1}{Coorientador: Giuliano Sant’Anna Marotta}\\[10pt]
		%\scalebox{1}{}\\[100mm]
		\vfill
		\scalebox{1}{Brasília, XX de Maio de 2022}
\end{center}}]{Figuras/capa_tf.pdf}

\thispagestyle{empty}

\clearpage

%%%%%%%%%%%%%%%% FOLHA DE ROSTO

\begin{center}
	\scalebox{1.1}{\sffamily{Danilo Portela de Oliveira} }\\
	\scalebox{1.1}{\sffamily{} }
	
	\vspace{50mm}
	
	\scalefont{1.5}
	{\sffamily{\textbf{\large{Desenvolvimento de metodologia de tomografia sísmica \\ para aplicações rasas}} }}
	\scalefont{0.67}
	
\end{center}

\vspace{35mm}

\begin{flushright}

\begin{list}{}{
      \setlength{\leftmargin}{8.5cm}
      \setlength{\rightmargin}{0cm}
      \setlength{\labelwidth}{0pt}
      \setlength{\labelsep}{\leftmargin}}

      \item Monografia submetida ao curso de graduação em Geofísica da Universidade de Brasília como requisito para obtenção do Título de Bacharel em Geofísica.
\end{list}
      
\end{flushright}

\begin{center}
	\vspace{15mm}

	Orientador: Marcelo Peres Rocha \\
	Coorientador: Giuliano Sant’Anna Marotta
	
	\vfill
	
	Brasília, XX de Maio de 2022
\end{center}

\clearpage

%%%%%%%%%%%%%%%Agradecimentos%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
    \large{\textbf{Agradecimentos}}
\end{center}

\blindtext

\blindtext

\blindtext


\clearpage

\clearpage
\hspace{1mm}

\vfill

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{flushright}
	\begin{itshape}
		``If I have seen further it is by standing on the shoulders of Giants.''\\ Sir Isaac Newton
	\end{itshape}
\end{flushright}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
    \large{\textbf{Resumo}}
\end{center}

\blindtext 
%
\blindtext 
%
\blindtext 
%
\blindtext \\

\textbf{Palavras-chave}: \\ \\ ...

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
    \large{\textbf{Abstract}}
\end{center}

\blindtext 
%
\blindtext 
%
\blindtext 
%
\blindtext \\
\\
\\
\\
\textbf{Keywords}:
\\
\\
...



\clearpage

\begin{center}
\listoffigures \newpage % Plotar a lista de figuras
\end{center}

\begin{center}
\listoftables \newpage % Plotar a lista de tabelas
\end{center}

\begin{center}
    \large{\textbf{Lista de Símbolos}}
\end{center}

\vspace{0.5cm}

\begin{comment}
$V_{p}$ - Velocidade da onda sísmica P

\vspace{0.5cm}

$V_{s}$  - Velocidade da onda sísmica S

\vspace{0.5cm}

$k$ - Módulo de compressibilidade

\vspace{0.5cm}

$\mu$ - Módulo de cisalhamento

\vspace{0.5cm}

$\rho$ - Densidade do meio

\vspace{0.5cm}

$\sigma$ - Razão de Poisson

\vspace{0.5cm}

$\lambda$ - Primeiro coeficiente de Lamé

\vspace{0.5cm}

$\delta$ - Delta de Dirac

\vspace{0.5cm}

$\ast$ - Convolução

\vspace{0.5cm}

$\otimes$ - Correlação

\vspace{0.5cm}


$G$ - Função de Green

\vspace{0.5cm}

$f_{p}$ - Frequência de pico

\vspace{0.5cm}

$g_{2}$ - 2$^{a}$ Derivada da Gaussiana (Ricker)

\vspace{0.5cm}

$tmod$ - Tempo total de gravação 

\vspace{0.5cm}

MWCS - \emph{Moving Window Cross Spectral}
\end{comment}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
\tableofcontents \newpage % Plotar o sumário
\end{center}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section[Introdução]{Introdução}


\blindtext 
%
\blindtext 
%
\blindtext 
%
\blindtext

%%%%%

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Fundamentação Teórica}

\subsection{Formulando problemas inversos}

O ponto de partida na maioria dos problemas inversos é uma descrição dos dados. Como na maioria dos problemas inversos os dados são simplesmente uma tabela de valores numéricos, um vetor fornece um meio conveniente de sua representação \citep{menke1984geophysical}.

Se as medições $N$ forem realizadas em um experimento específico, por exemplo, pode-se considerar esses números como os elementos de um vetor $\textbf{d}$ de comprimento $N$. Da mesma forma, os parâmetros do modelo podem ser representados como os elementos de um vetor $\textbf{m}$, que é de comprimento $M$.

\begin{equation}\label{eq:tomography}
\begin{split}
\textrm{dados}: \textbf{d} &= [d_{1}, d_{2}, d_{3}, d_{4}, \dots, d_{N}]^T \\
\textrm{parâmetros do modelo}: \textbf{m} &= [m_{1}, m_{2}, m_{3}, m_{4}, \dots, m_{N}]^T
\end{split}
\end{equation}

Aqui $T$ significa a matriz transposta. 

A afirmação básica de um problema inverso é que os parâmetros do modelo e os dados estão de alguma forma relacionados. Essa relação é chamada de \textit{modelo}. Normalmente, o modelo assume a forma de uma ou mais fórmulas que os dados e os parâmetros do modelo devem seguir.

Se, por exemplo, alguém estivesse tentando determinar a densidade de um objeto medindo sua massa e volume, haveria dois dados - massa e volume (digamos, $d_{1}$ e $d_{2}$, respectivamente) - e um parâmetro de modelo desconhecido, densidade (digamos, $m_{1}$). O modelo seria a afirmação de que densidade vezes volume é igual a massa, o que pode ser escrito de forma compacta pela equação vetorial $d_{2}m_{1} = d_{1}$.

Em situações mais realistas, os dados e os parâmetros do modelo são relacionados de maneiras mais complicadas. Mais geralmente, os dados e os parâmetros do modelo podem estar relacionados por uma ou mais equações implícitas, como

\begin{equation}\label{eq:formulation}
\begin{matrix}
f_{1}(\textbf{d, m}) &=& 0 \\
f_{2}(\textbf{d, m}) &=& 0 \\
&\vdots \\
f_{L}(\textbf{d, m}) &=& 0 \\
\end{matrix}
\end{equation}

Onde $L$ é o número de equações. As Equações em  ~(\ref{eq:formulation}) da página~\pageref{eq:formulation} relativos à medição de densidade, $L = 1$ e $d_{2}m_{1} = d_{1}$ constituiria a única equação da forma $f_{1}(\textbf{d, m}) = 0$. Essas equações implícitas, que podem ser escritas de forma compacta como a equação vetorial $\textbf{f(d, m)} = 0$, resume o que se sabe sobre como os dados medidos e os parâmetros desconhecidos do modelo estão relacionados. O propósito da teoria inversa é resolver, ou ``inverter'', essas equações para os parâmetros do modelo, ou quaisquer tipos de respostas que possam ser possíveis ou desejáveis em qualquer situação.

Nenhuma afirmação é feita de que as equações $\textbf{f(d, m)} = 0$ contenham informações suficientes para especificar os parâmetros do modelo de forma única ou que sejam consistentes. Um dos propósitos da teoria inversa é responder a esses tipos de perguntas e fornecer meios de lidar com os problemas que elas implicam. Em geral, $\textbf{f(d, m)} = 0$ pode consistir em funções arbitrariamente complicadas (não lineares) dos dados e parâmetros do modelo. Em muitos problemas, no entanto, a equação assume uma das várias formas simples.

\subsubsection{Forma linear implícita}

A função $\textbf{f}$ é linear em ambos os parâmetros de dados e modelo e, portanto, pode ser escrita como a equação matricial (Equações em~(\ref{eq:formulation}) da página~\pageref{eq:formulation}). O Problema Linear Inverso

\begin{equation}\label{eq:matriz}
\textbf{f(d, m)} = 0 = \textbf{F}
\begin{bmatrix}
\textbf{d} \\
\textbf{m}
\end{bmatrix}
\end{equation}
onde $\textbf{F}$ é uma matriz $L \times (M + N)$.

\subsubsection{Forma explícita}

Em muitos casos, é possível separar os dados dos parâmetros do modelo e, assim, formar $L = N$ equações que são lineares nos dados (mas ainda não lineares nos parâmetros do modelo por meio de uma função vetorial $\textbf{g}$).

\begin{equation}\label{eq:forma_explicita}
\textbf{f(d, m)} = 0 = \textbf{d} - \textbf{g(m)}
\end{equation}

\subsubsection{Forma linear explícita}

Na forma linear explícita, a função $\textbf{g}$ também é linear, levando à equação matricial $N \times M$ (onde $L = N$)

\begin{equation}\label{eq:forma_linear_explicita}
\textbf{f(d, m)} = 0 = \textbf{d} - \textbf{Gm}
\end{equation}

Usar esta forma é equivalente a dizer que a matriz $\textbf{F}$ na Seção 2.1.1 é uma matriz diagonal.

\begin{equation}\label{eq:matriz_linear}
\textbf{F} = 
\begin{bmatrix}
\textbf{-I} & \textbf{0}\\
\textbf{0}	&	\textbf{G}
\end{bmatrix}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Exemplos de formulação de problemas inversos}

\begin{description}
	\item[Exemplo 1] |\textit{Ajustando uma linha reta} 
\end{description}

Suponha que $N$ medições de temperatura $T_{i}$ sejam feitas em profundidades $z_{i}$ na terra \citep{menke1984geophysical}. Os dados então são, um vetor $\textbf{d}$ de $N$ medições de
temperatura, onde $\textbf{d} = [T_{1}, T_{2}, T_{3}, \cdots, T_{N}]^T$. As profundidades $z_{i}$, não são, estritamente falando, dados. Em vez disso, eles fornecem algumas informações auxiliares que descrevem a geometria do experimento. Essa distinção será melhor esclarecida a seguir.

Suponha que assumimos um modelo no qual a temperatura é uma função linear da profundidade: $T = a + bz$. O coeficiente linear $a$ e o coeficiente angular $b$ formam então os dois parâmetros do modelo do problema, $\textbf{m} = [a, b]^T$. De acordo com o modelo, cada observação de temperatura deve satisfazer $T = a + bz$: 

\begin{equation}\label{eq:formulation_tem}
\begin{matrix}
T_{1} &=& a + bz_{1} \\
T_{2} &=& a + bz_{2} \\
&\vdots \\
T_{N} &=& a + bz_{N} \\
\end{matrix}
\end{equation}

Essas equações~(\ref{eq:formulation_tem}), página~\pageref{eq:formulation_tem}, podem ser organizadas como a equação matricial $\textbf{Gm = d}$: \\

\begin{equation}\label{eq:matriz_temperatura}
\begin{bmatrix}
T_{1} \\
T_{2} \\
\vdots \\
T_{N}\\
\end{bmatrix} = 
\begin{bmatrix}
1 & z_{1} \\
1 &	z_{2} \\
\vdots & \vdots \\
1 & z_{N} \\
\end{bmatrix}
\begin{bmatrix}
a \\
b \\
\end{bmatrix}
\end{equation} \\

\begin{description}
	\item[Exemplo 2] |\textit{Tomografia acústica} 
\end{description}

Suponha que uma parede seja montada a partir de um arranjo retangular de tijolos~(Figura \ref{tomografia}, página~\pageref{tomografia}) e que cada tijolo seja composto de um tipo diferente de argila \citep{menke1984geophysical}. Se as velocidades acústicas das diferentes argilas diferem, pode-se tentar distinguir os diferentes tipos de tijolos medindo o tempo de viagem do som através das várias fileiras e colunas de tijolos na parede. Os dados deste problema são $N = 8$ medições de tempo de percurso, $\textbf{d} = [T_{1}, T_{2}, T_{3}, \cdots, T_{8}]^T$. 

O modelo assume que cada tijolo é composto de um material uniforme e que o tempo de percurso do som através de cada tijolo é proporcional à largura e altura do tijolo. O fator de proporcionalidade é a vagarosidade (\textit{slowness}) do tijolo $s_{i}$, dando assim $M = 16$ parâmetros do modelo $\textbf{m} = [s_{1}, s_{2}, s_{3}, \cdots, s_{16}]^T$, onde a ordenação está de acordo com o esquema de numeração da figura como \\


\begin{equation}\label{eq:formulation_tomografia}
\begin{matrix}
Linha 1: T_{1} &=& hs_{1} + hs_{2} + hs_{3} + hs_{4} \\
Linha 2: T_{2} &=& hs_{5} + hs_{6} + hs_{7} + hs_{8} \\
&\vdots \\
Coluna 4: T_{8} &=& hs_{4} + hs_{8} + hs_{12} + hs_{16} \\
\end{matrix}
\end{equation} \\
e a equação matricial é \\

\begin{equation}\label{eq:matriz_tomografia}
\begin{bmatrix}
T_{1} \\
T_{2} \\
\vdots \\
T_{8}\\
\end{bmatrix} = h \left[
\begin{array}{cccccccccccccccc}
1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\
\end{array}\right]
\begin{bmatrix}
s_{1} \\
s_{2} \\
\vdots \\
s_{16}\\
\end{bmatrix}
\end{equation}

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.45]{Figuras/tomografia.png}
	\end{center}
	\caption{O tempo de percurso das ondas acústicas (linhas tracejadas) através das linhas e colunas de uma matriz quadrada de tijolos é medido com a fonte acústica $\textbf{S}$ e o receptor $\textbf{R}$ colocados nas bordas do quadrado. O problema inverso é inferir as propriedades acústicas dos tijolos (que são assumidas como homogêneas). \cite{menke1984geophysical}.}
	\label{tomografia}
\end{figure}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{O Problema Linear Inverso}

Os problemas inversos mais simples e mais bem compreendidos são aqueles que podem ser representados com a equação linear explícita $\textbf{Gm = d}$. Esta equação, portanto, forma a base do estudo da teoria inversa discreta. Muitos problemas inversos importantes que surgem nas ciências físicas envolvem precisamente essa equação. Outros, embora envolvam equações mais complicadas, muitas vezes podem ser resolvidos por meio de aproximações lineares.

A matriz $\textbf{G}$ é chamada de \textit{data kernel}, em analogia à teoria das equações integrais, na qual os análogos aos vetores de parâmetros de dados e modelos são duas funções contínuas $d(x)$ e $m(x)$, onde $x$ é alguma variável independente. As duas funções estão relacionadas pela equação

\begin{equation}\label{eq:inversão}
d(x) = \int G(x, \xi)m(\xi)d\xi
\end{equation}
onde a função $G(x, \xi)$ é o \textit{kernel}, ou função de Green, da equação integral. A solução de problemas desse tipo está dentro do escopo da teoria inversa contínua.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Tomografia}

O objetivo basal da Geofísica é obter informações a cerca dos parâmetros físicos das rochas que constituem o interior da Terra a partir de dados medidos em superfície, em poços ou em levantamentos aéreos \citep{reis2015aplicaccao}. Na modelagem direta, aplicam-se as equações que descrevem as leis da física sobre um modelo previamente definido para a obtenção de dados de resposta referentes aos parâmetros físicos desse tal modelo. Em contra partida, no problema inverso, já se possui os dados de resposta, aqueles obtidos através de levantamentos, e, portanto, o objetivo agora é a estimativa de um modelo que, quando aplicado a uma determinada relação físico-matemática, melhor se adéque aos dados medidos.

A tomografia sísmica é uma metodologia de inferência de parâmetros numéricos, usada na Geofísica, que extrai informações contidas em registros sísmicos para estimar modelos bidimensionais ou tridimensionais do interior da Terra \citep{rawlinson2010seismic}. Em geral, requer a solução de um problema inverso para se obter um modelo de velocidades sísmicas que seja consistente com as observações de campo. Desde que seja possível estabelecer um modelo aproximado $\textbf{d} = g(\textbf{m})$ , entre o vetor de dados sísmicos $\textbf{d}$ e o vetor de parâmetros do modelo sísmico $\textbf{m}$ - de modo que, para um dado modelo $\textbf{m}$, seja possível prever $\textbf{d}$ - procura-se, na tomografia sísmica, encontrar $\textbf{m}$ tal que $\textbf{d}_{obs} = g(\textbf{m})$, onde $\textbf{d}_{obs}$ é o vetor de dados observados.

As relações do tipo $\textbf{d} = g(\textbf{m})$, em sua grande maioria, são não-lineares e não solucionáveis analiticamente \citep{reis2015aplicaccao}, por isso, busca-se a linearização dessas relações através de
métodos numéricos. Com isso, devido a essa não-linearidade do problema inverso, a superfície da função-objetivo dos tempos de percurso pode não vir a ser simples, bem comportada ou com um único mínimo bem definido. 

Devido, também, ao caráter discreto dos dados geofísicos, faz-se necessário o uso de uma formulação matricial para o tratamento desses dados \citep{reis2015aplicaccao}. O objetivo agora, então, é criar uma aproximação linearizada $\textbf{Gm = d}$, onde $\textbf{d}$ é um vetor p-dimensional que carrega os dados medidos nos levantamentos, $\textbf{m}$ é um vetor n-dimensional que carrega os parâmetros do modelo o qual se quer estimar a partir das medidas, e $\textbf{G}$ é uma matriz de dimensões $\textit{p}$ por $\textit{n}$ que, se inversível, nos levaria facilmente a solução do problema através da relação $\textbf{m} = \textbf{G}^{-1}\textbf{d}$. Todavia, na quase totalidade dos problemas geofísicos, os problemas são
mal postos \citep{reis2015aplicaccao}, ou seja, não obedecem aos critérios de existência, unicidade e estabilidade simultaneamente; e $\textbf{Gm = d}$ constitui-se num sistema sobredeterminado $(\textit{m} > \textit{n})$, onde $\textbf{G}$ não é, à rigor, inversível; e, portanto, se faz necessário o uso de métodos numéricos mais complexos e, também, a consulta de informações geológicas à priori que, de alguma forma, limite os graus de liberdade do problema.

A tomografia sísmica possui grande importância no processamento sísmico. Através dela, é possível extrair diversas informações dos registros sísmicos, os quais se incluem tempos de percurso, amplitudes, conteúdo de frequências ou, até mesmo, a forma total da onda. Ela pode ser considerada, por exemplo, um complemento natural para a migração sísmica, pois oferece um meio de estimar a velocidade e a profundidade de interfaces usando tempos de percurso e, com menos frequência, amplitudes de espalhamento geométrico e coeficientes de reflexão/transmissão \citep{reis2015aplicaccao}.

\subsubsection{Tomografia sísmica por tempo de percurso}

A inversão sísmica de tempo de percurso para a estrutura de velocidades é um problema não linear, uma vez que os raios sísmicos, atuando como caminhos integrais em uma inversão tomográfica, dependem também da velocidade média (\citealp{worthington1984introduction}; \citealp{zhou2003crosshole}). Em vez de determinar os caminhos de raios desconhecidos e a estrutura de velocidade desconhecida simultaneamente, muitas vezes usa-se uma solução linearizada de forma iterativa para resolver as perturbações do modelo, em vez dos parâmetros do modelo diretamente \citep{bording1987applications}. As perturbações do modelo são consideradas pequenas o suficiente para que se possa considerar a relação entre as perturbações do modelo e os resíduos correspondentes como linear. Uma vez que as perturbações do modelo tenham sido encontradas, elas são adicionadas ao modelo atual para produzir o modelo para a iteração seguinte até que o resultado convirja.

Na prática, os dados sísmicos às vezes contêm uma quantidade considerável de ruído. Para dados de tempo de percurso, a precisão de leitura finita é a principal fonte de erros de dados. Para reduzir os erros, um método de pré-processamento é calcular a média dos dados de tempo de percurso de caminhos de raios semelhantes \cite{rohm2000effects}, mas esse método pode funcionar apenas em tomografia telessísmica, pois os erros são relativamente pequenos em comparação com os dados reais do tempo de percurso. Para mitigar os erros de dados, \cite{wang2000seismic} separaram os dados de tempo de percurso com ruído usando uma regressão ponderada localmente para se livrar dos valores discrepantes ou reduzir o peso dos grandes erros de separação. Para reduzir o efeito de erros de dados durante a inversão, \cite{scales1988fast} usaram coeficientes de ponderação em função do tempo de percurso residual em um esquema de mínimos quadrados iterativamente reponderado. Esses pesos baseados em resíduos, no entanto, são subjetivos, uma vez que os erros de dados na prática podem ter uma distribuição não Gaussiana e, portanto, o resíduo de dados pode ser enviesado. \cite{cao1995relative} montaram um esquema de inversão não linear baseado em erro relativo para dados sísmicos de \textit{crosshole} que tenta superar o viés dos métodos de mínimos quadrados que tendem a enfatizar raios com maiores tempos de percurso.

\subsubsection{Reconstrução na tomografia sísmica de tempo de percurso}

O problema de reconstruir imagens por projeções, isto é, reconstruir uma função através de suas integrais ao longo de retas surgiu independentemente em diversos ramos da ciência tais como na Geofísica, Astrofísica, Medicina e dentre
outros. 

Provavelmente os exemplos que causaram maior impacto na vida moderna foram em prospecção sísmica e na tomografia computadorizada voltada para diagnósticos clínicos.

O termo tomografia surge do prefixo grego ``tomo'' que quer dizer fatia, o que nos sugere uma reconstrução em 2-D. Mas a palavra já é utilizada rotineiramente para se referir a reconstrução de imagens em 3-D, sobretudo pelos sismólogos e radiólogos.

A tomografia sísmica tem como preocupação, a reconstrução de imagens de estruturas em subsuperfície. Dentre as técnicas existentes focalizaremos a que utiliza dados de tempo de percurso \citep{tempopercurso}.

Iniciaremos com a descrição do Princípio de Fermat. Neste contexto, é natural introduzir a vagarosidade, ou seja, a inversa da velocidade.

Dada $s$ uma distribuição contínua da vagarosidade $s(x)$, \textit{o tempo de percurso} de um sinal ao longo de um possível caminho que liga a fonte que o emitiu ao receptor é dado pela Equação~(\ref{eq:tempo_percurso}) da página~\pageref{eq:tempo_percurso}:

%%%%%%%%%%%%%%%%Início - Equação%%%%%%%%%%%%%%%%%%%%%%

\begin{equation}\label{eq:tempo_percurso}
\tau^p(s) = \int_P s(x) \, dl^P = \int_P \frac{1}{v(x)} \, dl^P
\end{equation}

%%%%%%%%%%%%%%%%Fim - Equação%%%%%%%%%%%%%%%%%%%%%%%%%

Onde $dl^P$ denota o comprimento de arco ao longo do caminho $P$. Denotemos por $\tau$ o conjunto de todos os possíveis caminhos ligando a fonte ao receptor.

O Princípio de Fermat diz que o caminho físico percorrido por uma onda entre dois pontos é aquele que minimiza o tempo de percurso.

%%%%%%%%%%%%%%%%Início - Equação%%%%%%%%%%%%%%%%%%%%%%

\begin{equation}\label{eq:tempo_min}
\tau^*(s) = min_{P \in \{\tau\}} \tau^P (s)
\end{equation}

%%%%%%%%%%%%%%%%Fim - Equação%%%%%%%%%%%%%%%%%%%%%%%%%

O funcional $P \mapsto \tau^p(s)$ de tempo de percurso é estacionário com respeito a pequenas pertubações no caminho de Fermat $P^*(s)$ no sentido do cálculo das variações \citep{Axelsson}. Observe que a Equação~(\ref{eq:tempo_min}) da página~\pageref{eq:tempo_min} depende de forma não linear em \textit{s}, como consequência do processo de minimização.

Uma forma de obter dados na tomografia sísmica é feita aproveitando a existência de poços já perfurados. Isto é, colocando transmissores em um dos poços e receptores em outro de maneira que são emitidas ondas entre os poços.
Tais ondas podem ser sísmicas ou eletromagnéticas. Através da utilização de receptores apropriados mede-se o tempo de chegada das mesmas.

Esses dados, apesar de imprecisos e ruidosos, podem ser utilizados para obtermos informações sobre a composição do subsolo e a presença de hidro-carbonetos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Problema Direto}

Dentro de uma aproximação aceitável para muitas finalidades em Geofísica, podemos modelar as ondas sísmicas como soluções da equação diferencial parcial:

\begin{equation}\label{eq:problema_direto}
\partial_{t}^2 \phi - c^2(x)  \Delta \phi = g(x, t)
\end{equation}
onde $g(x, t)$ é a intensidade da pertubação num determinado ponto $x$ e tempo $t$. Temos que $\phi (x, t)$ é a intensidade da onda no tempo $t$ e posição $x$. Esta equação deve ser complementada com condições de contorno apropriadas.

O problema direto consiste em resolver a equação dado $g$, isto é, encontrar a solução $\phi$. No caso da tomografia por tempo de percurso, a preocupação é determinar o tempo de percurso da frente de onda e o caminho percorrido pela mesma entre fonte e receptor. Para saber mais sobre as técnicas de resolução desse tipo de problema direto ver \citep{rawlison}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Problema Inverso}

Para o problema inverso~(Figura \ref{direto_inverso}\textbf{a}, página~\pageref{direto_inverso}), queremos obter informações sobre os coeficientes da equação utilizando dados sobre suas soluções em regiões distintas. As técnicas de problemas inversos são de grande interesse na prospecção sísmica, pois têm por objetivo, determinar o interior da região em estudo somente com base em informação parcial dos dados no exterior da mesma. Assim, nos propomos a reconstruir os valores de $c(x)$ com base na solução da
equação da onda medida na fronteira que delimita a região de interesse. Com essas informações em mãos, os geólogos e geofísicos podem inferir que tipo de material existe no subsolo estudado fazendo uso de informações como por
exemplo na Figura~\ref{material} (página~\pageref{material}).

Na inversão linear na tomografia por tempo de percurso, assumimos à priori que sabemos o traçado dos feixes que ligam fonte a receptor, o que é justificado por uma aproximação linear que ignora a dependência que os caminhos possuem da distribuição da vagarosidade (Princípio de Fermat).

Na~Figura \ref{direto_inverso}\textbf{a} (página~\pageref{direto_inverso}) descrevemos simplificadamente uma comparação entre o problema direto e o problema inverso. O problema inverso é relativamente mais complicado, uma vez que, em problemas reais, fixados os dados, podemos construir infinitos modelos que se adéquam a estes mesmos dados. No problema inverso, muitas vezes não há essa unicidade levando dos dados ao modelo. Assim, chegamos a um esquema mais adequado à realidade na Figura~\ref{direto_inverso}\textbf{b} (página~\pageref{direto_inverso}).

A não unicidade do problema inverso pode ser explicada pelo fato de possuirmos somente uma quantidade finita de dados coletados para obter um modelo que muitas vezes é uma função contínua de suas variáveis, o que significa, que o mesmo possui infinitos graus de liberdade. Por causa dessa limitação física da finitude dos dados, o modelo que alcançamos através dos dados coletados não é necessariamente o que modela a realidade.

São necessários dois passos na inversão para chegarmos a um modelo mais próximo da realidade. Isto é representado na Figura~\ref{direto_inverso}\textbf{b} (página~\pageref{direto_inverso}). Vale salientar que em última análise o modelo verdadeiro não é sabido em problemas reais.

O primeiro passo seria então reconstruir um modelo $m'$ utilizando os dados $d$. Uma vez feito isto, determinamos que propriedades o modelo $m'$ preserva do modelo real $m$ e que tipo de erros e ruídos estão associados a ele, ou seja,
fazemos uma avaliação do modelo.

\begin{figure}[!hbtp]
	\begin{center}
		
		\includegraphics[scale=0.43]{Figuras/problema_direto_x_inverso.png}
	\end{center}
	\caption{(a) Problema Direto versus Problema Inverso. (b) O problema inverso visto com duas etapas. \cite{tempopercurso}.}
	\label{direto_inverso}
\end{figure}

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.32]{Figuras/material.png}
	\end{center}
	\caption{Gráfico de materiais de acordo com a velocidade. Assim, com a solução obtida pela tomografia de tempo de percurso, os geólogos e geofísicos podem inferir que tipo de material existe no subsolo. \cite{tempopercurso}.}
	\label{material}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Modelos (Representação da Estrutura)}

Mostraremos duas maneiras de parametrizar a vagarosidade \citep{tempopercurso}. O mais simples seria dividir a região em pequenos blocos (denominados pixels no caso 2-D e voxels no caso 3-D) e atribuir valores constantes à vagarosidade em cada bloco. Isto pode ser visto na Figura~\ref{modelos}\textbf{a} (página~\pageref{modelos}). 

Uma alternativa a este modelo é definir vagarosidade nos vértices da malha formada pela divisão da região em blocos (Figura~\ref{modelos}\textbf{b}, página~\pageref{modelos}). Essa definição seria
formulada em conjunto com uma função de interpolação. Um exemplo ilustrativo disto seria no contexto de tomografia local de terremotos, tal que para cada vértice $(x, y, z)$ é utilizada uma interpolação trilinear (figura~\ref{modelos}\textbf{c}, página~\pageref{modelos}):

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.50]{Figuras/modelos.png}
	\end{center}
	\caption{Modelos. \cite{tempopercurso}.}
	\label{modelos}
\end{figure}

\begin{equation}\label{eq:estrutura}
v(x, y, z) = \sum_{i=1}^{2} \sum_{j=1}^{2} \sum_{k=1}^{2} V(x_{i}, y_{j}, z_{k})\left(1 - \left|\frac{x - x_{i}}{x_{2} - x_{1}}\right|\right)\left(1 - \left|\frac{y - y_{j}}{y_{2} - y_{1}}\right|\right)\left(1 - \left|\frac{z - z_{k}}{z_{2} - z_{1}}\right|\right)
\end{equation} \\
onde $V(x_{i}, y_{j}, z_{k})$ são os valores da velocidade nos oito vértices que cercam o vértice $(x, y, z)$.


Para este trabalho estamos interessados em entender o primeiro modelo acima (Figura~\ref{modelos}\textbf{a}, página~\pageref{modelos}). Sendo assim, considere $t_{1}, \cdots, t_{m}$ conjunto de tempos de percurso entre fonte e receptor. Dado um modelo com n células, podemos escrever, 

\begin{equation}\label{eq:percurso}
t_{i} = \sum_{j=1}^{n} l_{ij}s_{j},
\end{equation}

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.60]{Figuras/tempo_percurso.png}
	\end{center}
	\caption{Tempo de percurso para a $i$-ésima frente de onda, onde está sendo utilizado o modelo discretizado com vagarosidade constante em cada pixel. \cite{tempopercurso}.}
	\label{modelos_percurso}
\end{figure} \newpage
Ou melhor,  $Ms = t$. Onde $M$ é a matriz formada pelo comprimento $l_{ij}$ do $i$-ésimo raio que passa pela $j$-ésima célula e $s$ é a vagarosidade (a nossa incógnita). Observe que

\begin{equation}\label{eq:percurso_comprimento}
l_{ij} = \frac{\partial t_{i}}{\partial s_{j}}
\end{equation}
e assim,

\begin{equation}\label{eq:percurso_comprimento2}
t_{i} = \frac{\partial t_{i}}{\partial s_{1}}s_{1} + \frac{\partial t_{i}}{\partial s_{2}}s_{2} + \cdots + \frac{\partial t_{i}}{\partial s_{n}}s_{n}.
\end{equation}
\\

Assim, discretizando o domínio da vagarosidade obtemos um sistema de equações lineares, onde a matriz do sistema é muito esparsa (A densidade de uma matriz é o número de elementos não nulos dividido pelo total de elementos da matriz. Se esse número for muito pequeno essa matriz é dita esparsa) porque cada raio intersecta somente uma pequena fração dos voxels da discretização (ver Figura~\ref{modelos_percurso}, página~\pageref{modelos_percurso}). Então para os pixels em 2-D, cada raio intersecta algo da ordem de $m * n$ pixels em uma malha $m \times n$. Isso torna o problema particularmente atrativo para a utilização de soluções iterativas. 

A matriz $M$ contém todas as informações físicas e matemáticas que escolhemos para o modelo no problema dado. Assim, no caso da tomografia por tempo de percurso, a matriz
$M$ terá como suas componentes os dados do comprimento das trajetórias.

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.60]{Figuras/diagrama.png}
	\end{center}
	\caption{Diagrama de um experimento tomográfico. A matriz $M$ geralmente é esparsa, pois existem células por onde não passam nenhum raio do experimento. \cite{tempopercurso}.}
	\label{modelos_diagrama}
\end{figure} \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Matriz de percurso dos raios}

As entradas em $\textbf{S}$ (Figura~\ref{matriz_convergencia}, página~\pageref{matriz_convergencia}) são calculadas identificando a interseção de forma individual do raio \textit{`m'} com os limites do pixel \textit{`n'} e computando o comprimento (relação de Pitágoras) \textit{`d'} dentro do elemento \citep{RBGf1495}. Portanto, o tamanho de $\textbf{S}$ crescerá com o incremento das medidas e/ou densidade de discretização.

Considerando a Figura~\ref{raios} (página~\pageref{raios}) e tendo ainda em mente a Figura~\ref{matriz_convergencia} (página~\pageref{matriz_convergencia}); o número de fontes e receptores é $7$ e então o número total de raios é $49$ (constante para esta matriz). Se o meio for dividido em $7 \times 7 = 49$ pixels, $\textbf{S}$ será de 49 linhas ($M$, número de raios) por 49 colunas ($N$ , número de pixels, cujas vagarosidades (\textit{slowness}) são desconhecidas). É relevante notar que o incremento da densidade de pixels $(N)$, levará a considerar mais pixels no cálculo dos caminhos de viagem para cada receptor.

Este sistema de equações é \textit{aparentemente} determinado (número de equações igual ao número de incógnitas). A palavra \textit{aparentemente} significa que em alguns casos (especialmente em \textit{cross-hole}, (ver \citealp{imhof2007caracterizacion}) o sistema está mal condicionado e a classificação de $\textbf{S} < N , M$. Isso dará um sistema subdeterminado levando a infinitas soluções. O mesmo ocorrerá, por exemplo, dividindo o meio em mais pixels para melhorar a resolução das imagens. (a limitação de dividir o meio com $N = M$ é que a resolução é grosseira, pois o tamanho dos pixels é grande).

Incrementar o número de transdutores para melhorar a resolução não é prático e sempre possível; primeiro, devido à quantidade de esforço de levantamento necessário (custo) e, segundo, se os raios estão tão próximos, a condição de matriz S aumenta e não necessariamente adiciona informações ao sistema (\citealp{santamarina1998introduction}; \citealp{fernandez2000tomographic}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Matriz de cobertura espacial}

O tamanho de $\textbf{S}$ (matriz de transformação) é $M$ linhas (número de medições) por $N$ colunas (número de vagarosidade - \textit{slowness} - de pixel desconhecido). A soma de cada coluna individual de $\textbf{S}$ traz o comprimento total percorrido pelos raios em um pixel (Figura~\ref{matriz_convergencia}, página~\pageref{matriz_convergencia}). Aplicando esta soma em todas as colunas de $\textbf{S}$, obtém-se um vetor linha $1 \times N$ que rearranjado seguindo o padrão geométrico, traz a matriz de cobertura espacial de $``s"$ pixels verticais por $``t"$ horizontais onde $N = s + t$. Considerou-se aqui $s = t$ \citep{RBGf1495}.

Dois exemplos de matrizes de cobertura espacial de \textit{cross-hole} são representados na Figura~\ref{raios_convergencia} (página~\pageref{raios_convergencia}) para 10 pares de fonte-receptor; \textbf{(a)} para 100 elementos e \textbf{(b)} 400 unidades. As zonas escuras indicam valores mais baixos de cobertura espacial. Isso significa que as informações coletadas para resolver a velocidade ou vagarosidade (\textit{slowness}) do mesmo são menores do que em outras zonas mais claras. Em outras palavras, a precisão para a avaliação dos valores dos pixels não será uniforme. Em virtude de haver mais raios que atravessam um pixel, há mais informações nele (semelhante ao conceito CDP - \textit{Common Depth Point} - em sísmica de reflexão), o setor mais claro no centro da matriz de cobertura espacial representa a resolução e precisão máximas para o pixel/s ali situado. Mas o que acontece quando uma inclusão que está sendo buscada está longe dessa posição? A resolução para localizá-lo será mais pobre \citep{santamarina1998introduction}.

Uma forma alternativa de dividir o meio para melhorar a resolução nas zonas escuras é proposta: ao invés de separá-lo em pixels de mesmo tamanho e cobertura espacial diferente em cada um; ele será dividido em elementos de igual cobertura espacial e tamanhos individuais distintos e nomeados como ipixels. Devido a este fato, os elementos de $\textbf{S}$ serão diferentes. A Figura~\ref{ipixel} (página~\pageref{ipixel}) mostra o domínio dividido em duas densidades de ipixels. Os mesmos tons de cor representam a mesma informação em cada elemento.

Qualquer tipo de discretização de elementos para o domínio físico é perfeitamente possível de realizar porque qualquer tipo dela é apenas geométrica e tem por finalidade fazer a matriz $\textbf{S}$ e armar o sistema de equações tendo as distâncias percorridas pelos raios.

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.50]{Figuras/raios.png}
	\end{center}
	\caption{Traçado de raios. Discretização do espaço em 49 pixels. \textit{Cross-hole array}. \cite{RBGf1495}.}
	\label{raios}
\end{figure}

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.50]{Figuras/matriz_convergencia.png}
	\end{center}
	\caption{Matriz de percurso dos raios e significado de cobertura espacial. \cite{RBGf1495}.}
	\label{matriz_convergencia}
\end{figure}

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.42]{Figuras/raios_convergencia.png}
	\end{center}
	\caption{Gráficos de cobertura espacial para pixels. (a) $10 \times 10$ pixels, (b) $20 \times 20$ pixels. \cite{RBGf1495}.}
	\label{raios_convergencia}
\end{figure} 

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.44]{Figuras/ipixel.png}
	\end{center}
	\caption{Gráficos de cobertura espacial Ipixel. (a) $10 \times 10$ ipixels, (b) $20 \times 20$ ipixels (calculados a partir de uma matriz de cobertura espacial  uniforme de base de $100 \times 100$ pixels). \cite{RBGf1495}.}
	\label{ipixel}
\end{figure} \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Condicionamento de uma matriz}

Se houver um alto contraste entre os valores numéricos dos elementos dentro de uma matriz; é possível que a classificação calculada para ela tenha um número errôneo de linhas linearmente independente. Devido a isso, o número de condição $k$ é uma escolha melhor para estudar o condicionamento de uma matriz (ou seja, quão próximo está de uma matriz de classificação mais baixa) do que sua classificação (\citealp{strang1980linear}).

$k$ é definido como a razão entre os valores singulares com os valores absolutos máximos e mínimos (\citealp{computations1989johns}):

\begin{equation}\label{eq:k_equation}
k = \frac{max|\lambda _{i}|}{min |\lambda _{i}|}
\end{equation}

Uma matriz é dita mal condicionada se $k$ for muito grande. Geometricamente, os valores máximo e mínimo representam os eixos de uma elipse (\citealp{branham1990introduction}). Se a razão tende à unidade, a correlação é nula (independente) e se for muito grande, é quase perfeita (dependente) e portanto mal condicionada. Em outras palavras, mau condicionamento significa que o número de linhas ou colunas linearmente dependentes da matriz tende a aumentar. Isso significa que o número de equações/medidas diminui em relação ao número de incógnitas.

Por fim, os valores singulares dão uma indicação relacionada à confiança e à relação entre as medidas dos fenômenos. Valores pequenos sugerem informações limitadas sobre o parâmetro.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Regularização}

Problemas em tomografia geralmente são mal-postos, isto é, problemas que falham, seja na existência de soluções, na unicidade dessas soluções ou mesmo que a solução não depende continuamente dos dados (\citealp{tempopercurso}).  Sendo assim, são utilizadas frequentemente técnicas de regularização para dar estabilidade ao problema \citep{natterer2001mathematical}. Essas técnicas nos permitem solucionar não o problema original
mas sim, um problema similar, porém mais robusto em relação a erros nos dados.

Considere o problema de resolver $Ms = t$. Do ponto de vista matemático, no caso de modelos lineares, esses problemas mal-postos se devem geralmente ao fato da matriz $M$ possuir valores singulares nulos ou muito próximos de zero. Uma das formas de contornar isto seria acrescentar à matriz $M^{T}M$ um múltiplo da matriz identidade de tal maneira que essa nova matriz possua somente valores singulares positivos, porém distantes do zero. De fato, considerando $B = M^{T}M + \gamma I$, temos que se $\gamma \neq 0$, os autovalores de $B$ ficam diferentes de zero (positivos).

Feito isto, podemos definir a solução de mínimos quadrados amortecidos do sistema original por:

\begin{equation}\label{eq:regularization}
s' = (M^{T}M + \gamma I)^{-1}M^{T}t
\end{equation}

A escolha de um bom parâmetro $\gamma$ é fundamental nos problemas mal postos. O número $\gamma$ é chamado de parâmetro de regularização.

A não existência ou a perda de unicidade das soluções se devem ao fato de $t \notin Im(M)$ ou a não injetividade da transformação $M$, respectivamente. Nesses casos, a utilização da pseudo-inversa $M^{\dagger}$ é o mais conveniente. A técnica de regularização de Tikhonov consiste em obter certas transformações dadas denotadas por
$A_{\lambda}: \mathbb{R}^{n} \longrightarrow \mathbb{R}^{m}, \lambda > 0$, de tal forma,

\begin{equation}\label{eq:regularization_limite}
\lim_{\lambda \rightarrow 0} A_{\lambda}t = M^{\dagger}t
\end{equation}
onde $M^{\dagger}$ é a pseudo-inversa da matriz $M$.

Seja $t_{\epsilon} \in \mathbb{R}^{n}$ tal que $||t - t_{\epsilon}|| \leq \epsilon$. E seja $\lambda (\epsilon)$ tal que, quando $\epsilon \rightarrow 0$ 

\begin{equation}\label{eq:regularization_lim}
\lambda (\epsilon)  \rightarrow 0
\end{equation}
e

\begin{equation}\label{eq:regularization_codition}
||A_{\lambda (\epsilon)}||\epsilon \rightarrow 0
\end{equation}
assim,

\begin{equation}\label{eq:regularization_formulation}
||A_{\lambda (\epsilon)}t_{\epsilon} - M^{\dagger}t|| \leq ||A_{\lambda (\epsilon)}t_{\epsilon} - A_{\lambda (\epsilon)}t|| + ||A_{\lambda (\epsilon)}t - M^{\dagger}t|| \leq ||A_{\lambda (\epsilon)}|||t_{\epsilon} - t||| + ||A_{\lambda (\epsilon)}t - M^{\dagger}t|| \longrightarrow 0
\end{equation} \\

Logo, se $t_{\epsilon}$ está próximo do tempo de percurso $t$ então $A_{\lambda (\epsilon)}t_{\epsilon}$ está próximo
da solução aproximada $M^{\dagger}t$.

Como exemplo desse método consideremos a parada em um processo iterativo (\citealp{tempopercurso}). Seja então,

\begin{equation}\label{eq:regularization_formulation_exemplo}
s^{(k + 1)} = B_{k}s^{(k)} + C_{k}t
\end{equation}
um processo iterativo e assuma que $s^{(k)} \rightarrow M^{\dagger}t$. Para cada $\lambda > 0$, seja $k(\lambda)$ índice tal que $k(\lambda) \rightarrow \infty$ quando $\lambda \rightarrow 0$. Então afirmamos que $A_{\lambda}t = s^{(k(\lambda))}$ é uma regularização, pois

\begin{equation}\label{eq:regularization_formulation_exemplo2}
\lim_{\lambda \rightarrow 0} A_{\lambda}t = \lim_{\lambda \rightarrow 0} s^{(k(\lambda))} = M^{\dagger}t
\end{equation}
por hipótese.

Frequentemente no caso da tomografia por tempo de percurso a matriz $M$ (associada aos tempos de percurso dos raios sobre as células) tem posto deficiente ou é extremamente mal-condicionada. Isto leva naturalmente a necessidade de regularização.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section{Materiais e Métodos}

\subsection{Área de Estudo}

Para desenvolver a metodologia de tomografia sísmica para aquisição e processamento de dados em profundidades rasas (menores que 20 metros), inicialmente foi desenvolvido a técnica de maneira sintética e depois realizado uma aquisição em local com alvo conhecido, buscando otimizar os parâmetros de aquisição, e para calibrar as etapas de processamento. Tendo isso em vista, um alvo com dimensões e geometria conhecida foi instalado na área nos fundos do Observatório Sismológico no Campus Darcy Ribeiro da Universidade de Brasília (UnB), como pode ser observado na Figura~\ref{area_estudo} (página~\pageref{area_estudo}).
Como resultado, são gerados mapas de anomalias de velocidade que representa o alvo enterrado, e com isso, estabelecer um esquema de aquisição que permita resolver o alvo.

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.087]{Figuras/area-estudo.png}
	\end{center}
	\caption{Área de estudo nos fundos do Observatório Sismológico no Campus Darcy Ribeiro da Universidade de Brasília (UnB). A) Delimitando a área de estudo para a implantação do alvo. B) Imagem de satélite do Google Earth mostrando a localização da área de estudo (em vermelho).}
	\label{area_estudo}
\end{figure}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\subsubsection{Geologia}


A região de estudo como um todo (UnB) encontra-se no Grupo Paranoá, de idade Meso/Neoproterozóico, composto majoritariamente por rochas sedimentares como quartzitos com intercalações de metassiltitos, calcários e dolomitos (\citealp{pimentel2011tectonic}) e também uma parte no Grupo Bambuí que é a unidade sedimentar neoproterozóica mais importante do Brasil central. Ainda mais, possuí uma sequência pelítica composta por folhelhos, argilitos e ritmitos finos de coloração verde que gradam para o topo da unidade para siltitos feldspáticos ou arcoseanos e que na porção centro-norte do Distrito Federal foram encontrados calcários e dolomitos micríticos, folhelhos, margas e siltitos argilosos e ricos em mica detrítica atribuídos à base do Grupo Bambuí. Além deste, o Distrito Federal é composto geologicamente por outros dois conjuntos litológicos: grupos Canastra e Araxá. (\citealp{campos2004hidrogeologia}). (Figura~\ref{geologia}, página~\pageref{geologia}).


\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.37]{Figuras/geologia.jpeg}
	\end{center}
	\caption{Mapa geológico do Distrito Federal. Modificado de \cite{neumann2012mapeamento}.}
	\label{geologia}
\end{figure} \newpage

\subsubsection{Pedologia}

O solo da região de estudo é definido como Latossolo Vermelho. Com base no relatório da Empresa Brasileira de Pesquisa Agropecuária (\citealp{freitas1978levantamento}). O solo do DF pode ser classificado em dois núcleos em função dos tipos de coberturas. O primeiro é caracterizado pelo conjunto de tipos pedológicos mais abundantes, abrangendo 85\% do território, e é constituído pelas seguintes classes de solos: Latossolo Vermelho, Latossolo Vermelho-Amarelo e Cambissolo Háplico. Já o segundo grupo, abrange aproximadamente 15\% do território, e refere-se aos demais tipos de solos identificados dentro dos limites do DF, tais como: Nitossolo, Chernossolo, Gleissolo, Organossolo, Neossolo Quartzarênico, Neossolo Flúvico e Neossolo Litólico, além de Plintossolo. Assim também, o Plano Piloto de Brasília está localizado no primeiro grupo, com predominância de Latossolo Vermelho (Figura~\ref{solo}, página~\pageref{solo}). Ainda mais, da área abrangida pelos latossolos no Distrito Federal (85\%), o Latossolo Vermelho
ocupa 38,63\% (\citealp{martins2000petrografia}). Então, na área de estudo, o Latossolo Vermelho ocupa 100\% do solo.

Segundo o Zoneamento Ecológico-Econômico do Distrito Federal – ZEE-DF (2012), de maneira geral, os Latossolos Vermelhos possuem grande ocorrência associada à vegetação
de cerrado e topos das chapadas. O material de origem é bastante variado, desde arenitos até rochas pelíticas, desde que possuam teores razoáveis de ferro. Normalmente, os Latossolos Vermelhos exibem-se com perfis profundos, muito porosos e bastante permeáveis. Ocorre nas chapadas mais elevadas e divisores de drenagem mais contínuos, sobre as rochas do Grupo Paranoá (\citealp{martins2000petrografia}; ZEE-DF, 2012).

Este solo é constituído por uma sequência morfológica de horizontes com \textit{A} moderado, \textit{B} latossólico e \textit{C}. O horizonte superficial \textit{A} desenvolve-se com espessuras entre 20 e 50 cm e com coloração vermelho escuro. Neste horizonte há presença abundante de raízes, exibindo uma porção mais próxima a superfície, de tonalidade mais escura que a superior, indicando menor presença de matéria orgânica no nível superior por ação antrópica relativa a aterramento, visto que a área de estudo é uma área de jardinagem e que houve construção civil. Em geral, o horizonte \textit{A} tem estrutura granular, sendo muito friável quando úmido (\citealp{martins2000petrografia}; ZEE-DF, 2012).

O horizonte subsuperficial \textit{B} exibe um importante estágio de intemperização com textura argilosa e estrutura granular fraca, com espessura quase sempre maior que 250 cm.
Pode ser subdividido nos sub- horizontes \textit{Bw1} e \textit{Bw2}, no entanto, possui pouca ou nenhuma diferenciação entre eles (ZEE-DF, 2012).

O horizonte \textit{C} caracteriza-se como a camada abaixo do \textit{solum} (horizontes \textit{A} e \textit{B}) menos afetada por processos pedogenéticos mantendo características da rocha original. É
conhecido ainda como manto de alteração ou saprólito.

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.55]{Figuras/solo.png}
	\end{center}
	\caption{Mapa de solos da Bacia do Lago Paranoá. Modificado de \cite{menezes2010avaliaccao}.}
	\label{solo}
\end{figure} \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Frente teórica-computacional}

O trabalho foi elaborado em duas frentes: Uma teórico-computacional e outra experimental. Na frente teórico-computacional realizamos o desenvolvimento de rotinas computacionais para inversão dos dados de tempo de percurso (utilizando o tempo de chegada da onda direta). Utilizou-se de conceitos de inversão por mínimos quadrados com algum nível de regularização para controlar a ambiguidade do modelo de parâmetros (velocidade/vagarosidade). A estrutura computacional se necessária seria fornecida pelo Observatório Sismológico da UnB, e os programas/linguagens de programação utilizados são de código aberto (como Python, Matlab, Shellscript, etc). Elaborou-se modelos sintéticos com posição e propriedades físicas conhecidas das estruturas a serem simuladas. Os ajustes que por ventura sejam necessários foram incluídas no problema inverso, ou ainda, no esquema de aquisição. 

\begin{comment}
\begin{table}[!hbtp]
\centering
\caption{Parâmetros da aquisição sísmica realizada na barragem do Paranoá.}
\label{parametros_aquisicao_ativa}
\begin{tabular}{@{}lr@{}}
\toprule
\rowcolor[HTML]{FFFFFF} 
\multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}Parâmetros} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}Valores} \\ \midrule
\rowcolor[HTML]{EFEFEF} 
Comprimento da linha                                   & 475 m                                               \\
\rowcolor[HTML]{FFFFFF} 
Espaçamento dos receptores                             & 5 m                                                 \\
\rowcolor[HTML]{EFEFEF} 
Espaçamento das fontes                                 & 10 m                                                \\
\rowcolor[HTML]{FFFFFF} 
Frequência geofones                                    & 14 Hz                                               \\
\rowcolor[HTML]{EFEFEF} 
Tipo de fonte                                          & Ativa (marreta)                                     \\
\rowcolor[HTML]{FFFFFF} 
Stacks                                                 & 3                                                   \\
\rowcolor[HTML]{EFEFEF} 
Janela temporal                                        & 1500 ms                                             \\
Taxa de amostragem                                     & 0.25 ms                                              \\ \bottomrule
\end{tabular}
\end{table}
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	

\subsubsection{Recursos computacionais}

Para a construção da rotina computacional, tanto para o desenvolvimento da etapa de gerar dados sintéticos com também para a etapa de processar os dados de campo para obter os mapas de tomografia sísmica, usamos a linguagem de programação Python. Ainda mais, é uma linguagem de programação de alto nível, ou seja, com sintaxe mais simplificada e próxima da linguagem humana, utilizada nas mais diversas aplicações, como desktop, web, servidores e ciência de dados e mais especificadamente com a biblioteca pyGIMLI, a utilização dessa linguagem atualmente encontra-se em crescimento no ramo da Geofísica no que diz respeito ao desenvolvimento de diversas rotinas de processamentos, utilizando-se dos conceitos dos métodos Geofísicos.


Por outro lado, pyGIMLi é uma biblioteca de código aberto para modelagem e inversão em Geofísica(\citealp{Ruecker2017}). A biblioteca orientada a objetos fornece gerenciamento para malhas estruturadas e não estruturadas em 2D e 3D. Uma tarefa principal do pyGIMli é realizar inversão. Vários tipos de regularização em malhas (1D, 2D, 3D) com disposição regular ou irregular estão disponíveis. Existe um controle flexível de todos os parâmetros de inversão. A estrutura de inversão padrão é baseada no método generalizado de Gauss-Newton. O pyGIMLi vem com vários operadores Geofísicos avançados, que podem ser usados diretamente para um determinado problema.

Então, para que fosse possível o desenvolvimento do \textit{software}, as principais bibliotecas usadas foram o Matplotlib, Numpy e o pyGIMLi. O Matplotlib é um pacote de gráficos 2D usado em Python para desenvolvimento de aplicativos, scripts interativos e geração de imagens com qualidade de publicação em interfaces de usuário e sistemas operacionais (ver mais em \citealp{matplotlib}). No mundo Python, o NumPy é o pacote fundamental para computação científica. É uma biblioteca Python que fornece um objeto array multidimensional, vários objetos derivados (como arrays e matrizes) e uma variedade de rotinas para operações rápidas em arrays, incluindo matemática, lógica, manipulação de formas, classificação, seleção, I/O , transformadas discretas de Fourier, álgebra linear básica, operações estatísticas básicas e simulação aleatória (ver mais em \textit{\url{https://numpy.org/doc/1.22/}}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{pyGIMLi: Uma biblioteca de código aberto para modelagem e inversão em Geofísica}

O pyGIMLi oferece uma vantagem distinta, tal que pode ser facilmente estendido por módulos compilados de C ou Fortran, por exemplo, permitindo aos usuários estender o código licenciado ou terceirizar partes demoradas em extensões computacionalmente eficientes. Realiza-se o uso dessa flexibilidade e implementa-se todas as partes sensíveis ao tempo de execução em uma biblioteca principal C++. As ligações completas do Python para essa biblioteca principal são complementadas por funcionalidades escritas em Python puro, oferecendo, assim, eficiência e flexibilidade para o rápido desenvolvimento de aplicativos robustos de modelagem e inversão. O componente de modelagem oferece gerenciamento de malha, bem como solucionadores de elementos finitos e volumes finitos em 1D, 2D e 3D. O componente de inversão é baseado em um algoritmo determinístico de Gauss-Newton e funciona com qualquer operador direto físico fornecido. Várias rotinas de pós-processamento são fornecidas para visualizar os resultados em 2D usando Matplotlib (\citealp{Ruecker2017}) e em 3D usando o software ParaView (\citealp{ayachit2015paraview}) ou Mayavi (\citealp{ramachandran2011mayavi}). 

Um dos principais benefícios do uso do Python é a prototipagem abstrata, por exemplo, é implementado o principal solucionador inverso em C++ com o uso de uma matriz base abstrata e com isso é possível usá-lo com qualquer matriz avançada personalizada diretamente do Python. Isso resulta em flexibilidade dos tipos de matriz usados com esforço mínimo de codificação e deficiências mínimas de tempo de execução. Além de tipos densos e diferentes de matrizes esparsas, existem matrizes especializadas como matrizes em escala de linha ou coluna ou matrizes de Kronecker. Além disso, é implementada uma matriz de blocos contendo referências a um número de matrizes de tipo arbitrário. Ele pode ser usado para matrizes de restrição eficientes ou matrizes Jacobianas conjuntas sem perda de desempenho.
\\

\begin{description}
	\item[pyGIMLi] |\textit{Estruturas de inversão} 
\end{description}

Os \textit{frameworks} de inversão são abordagens generalizadas e abstratas para resolver um problema específico de inversão sem especificar os métodos geofísicos apropriados. Isso pode ser uma estratégia de regularização específica, uma formulação alternativa do problema inverso ou algoritmos de inversão de rotina.

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.45]{Figuras/arquitetura.png}
	\end{center}
	\caption{Arquitetura de software do pyGIMLi ilustrando seus componentes e diferentes níveis de abstração. A biblioteca Python foi construída sobre um núcleo C++ e várias dependências externas (caixa amarela). (Para interpretação das referências à cor nesta legenda da figura, o leitor deve consultar a versão web \url{https://www.pygimli.org/design.html\#sec-design}).}
	\label{arquitetura-pygimli}
\end{figure} \newpage

\begin{itemize}
	\item \textit{Inversão de Gauss-Newton}
	
	\hspace{0.5cm} A estrutura de inversão padrão é baseada no método generalizado de Gauss Newton e é compatível com qualquer operador direto e, portanto, aplicável a vários problemas físicos. Afirmamos o problema de inversão como minimização de uma função objetivo que consiste em desajuste de dados e restrições de modelo:
	
	\begin{equation}\label{eq:gauss}
	||\textbf{W}_{d}(\mathscr{F}(\textbf{m}) - \textbf{d})||_{2}^{2} + \lambda ||\textbf{W}_{m}(\textbf{m} - \textbf{m}_{0})||_{2}^{2} \rightarrow \textrm{min}
	\end{equation}
	
	\hspace{0.5cm} Observe que não foi incluído restrições de desigualdade na minimização, mas são usadas transformações para restringir os parâmetros a intervalos razoáveis (por exemplo, \citealp{kim2011unified}). $\textbf{W}_{d}$ é a matriz de ponderação de dados contendo os erros de dados inversos, $\textbf{W}_{m}$ é a matriz de restrição do modelo (por exemplo, um operador de rugosidade de primeira ordem) e $\textbf{m}_{0}$ é um modelo de referência. O fator adimensional $\lambda$ dimensiona a influência do termo de regularização. Existe uma ampla gama de diferentes métodos de regularização (diferentes tipos de suavidade e amortecimento, operadores mistos, suavização anisotrópica). A aplicação do esquema de Gauss-Newton na minimização (Equação \ref{eq:gauss} da página~\pageref{eq:gauss}) produz a atualização do modelo $\Delta \textbf{m}^{k}$ na $k$-ésima iteração (\citealp{park1991inversion}):
	
	\begin{equation}\label{eq:gauss-newton}
	\begin{matrix}
	
	(\textbf{J}^{T}\textbf{W}_{d}^{T}\textbf{W}_{d}\textbf{J}
	+ \lambda \textbf{W}_{m}^{T}\textbf{W}_{m})\Delta \textbf{m}^{k} = \textbf{J}^{T}\textbf{W}_{d}^{T}\textbf{W}_{d}(\Delta \textbf{d}^{k}) - \lambda \textbf{W}_{m}^{T}\textbf{W}_{m}(\textbf{m}^{k} - \textbf{m}^{0}) \\
	\textrm{com} \hspace{2mm} \Delta \textbf{d}^{k} = \textbf{d} - \mathscr{F}(\textbf{m}^{k}) \\ \textrm{e} \hspace{2mm} \Delta \textbf{m}^{k} = \textbf{m}^{k} - \textbf{m}^{k - 1}
	
	\end{matrix}
	\end{equation}
	
	que é resolvido usando um solucionador de mínimos quadrados de gradiente conjugado (\citealp{gunther2006three}). O processo de inversão incluindo a regularização específica da região é esboçado na Figura~\ref{inversao} (página~\pageref{inversao}).
	
	\begin{figure}[!hbtp]
		\begin{center}
			\includegraphics[scale=0.6]{Figuras/inversao.png}
		\end{center}
		\caption{Esquema de inversão generalizada. Operadores de encaminhamento já implementados ou personalizados podem ser usados para fornecer a função de resposta específica do problema e sua Jacobiana. Várias estratégias estão disponíveis para regularizar o problema inverso.}
		\label{inversao}
	\end{figure}

	\hspace{0.5cm} Todas as matrizes da formulação de inversão podem ser acessadas diretamente do Python e, assim, oferecem oportunidades para análise de incerteza e resolução, bem como design experimental (por exemplo, \citealp{wagner2015constructive}). Além de diferentes abordagens de inversão, existem os chamados \textit{frameworks} para tarefas típicas de inversão (principalmente de regularização). Exemplos que já estão implementados no pyGIMLi são, por exemplo:
	
	\hspace{0.5cm} \textbf{Marquardt scheme} inversão de alguns parâmetros independentes, por exemplo, ajuste de espectros (\citealp{loewer2015spectral}).
	
	\hspace{0.5cm} \textbf{Soil-physical model reduction} incorporando funções físicas do solo (\citealp{igel2016high}; \citealp{costabel2014noninvasive}).
	
	\hspace{0.5cm} \textbf{Classical joint inversion} de dois conjuntos de dados para o mesmo parâmetro como DC e EM (\citealp{gunther2013inversion}).
	
	\hspace{0.5cm} \textbf{Block joint inversion} de vários dados 1D usando camadas comuns, por exemplo, MRS+VES (\citealp{gunther2012hydraulic}).
	
	\hspace{0.5cm} \textbf{Sequential (constrained) inversion} inversão independente sucessiva de conjuntos de dados, por exemplo, \textit{classic time-lapse inversion} (por exemplo, \citealp{hubner2015monitoring}).
	
	\hspace{0.5cm} \textbf{Simultaneous constrained inversion} de conjuntos de dados de dados vizinhos no espaço (LCI, por exemplo, \citealp{costabel2016torus}), tempo (\textit{full time-lapse}) ou frequência (\citealp{gunther2016spectral}).
	
	\hspace{0.5cm} \textbf{Structurally coupled cooperative inversion} de dados díspares com base na semelhança estrutural (por exemplo, \citealp{ronczka2017electric}).
	
	\hspace{0.5cm} \textbf{Structure-based inversion} usando modelos 2D em camadas (\citealp{attwa2014structure}).
\end{itemize}

\begin{description}
	\item[pyGIMLi] |\textit{Parametrização} 
\end{description}

As malhas 2-D utilizadas para as rotinas de modelagem direta são compostas de retângulos aos quais são atribuídas velocidades, densidades e resistividades constantes. Os tamanhos das células são adaptados individualmente para cada método para levar em conta problemas de precisão numérica e eficiência computacional.

\begin{description}
	\item[pyGIMLi] |\textit{Modelagem direta} 
\end{description}

Para tomografia sísmica, os tempos de primeira chegada são calculados por um \textit{eikonal solver} (\citealp{podvin1991finite}) e depois os caminhos de raios associados são construídos por um \textit{steepest descent method} (\citealp{aldridge1993two}).

\begin{description}
	\item[pyGIMLi] |\textit{Meshing} 
\end{description}

\begin{itemize}
	\item \textit{Unstructured Meshes}
	
	\hspace{0.5cm} Um passo essencial na simulação numérica é encontrar uma discretização adequada de um domínio contínuo. Este é o problema da geração de malha. A geração de malhas é um componente chave para a simulação computacional de problemas físicos e de engenharia onde são usados métodos numéricos como os métodos dos elementos finitos, das diferenças finitas e dos volumes finitos (\citealp{teng2000unstructured}). Um método de simulação numérica normalmente aplica as seis etapas básicas a seguir.
	
	\begin{enumerate}
		\item \textbf{Modelagem matemática:} definir o domínio contínuo \textbf{$\Omega$} e as equações diferenciais parciais (EDP) sobre o domínio que modelam com precisão o problema físico e de engenharia;
		
		\item \textbf{Modelagem geométrica:} aproximar o domínio contínuo \textbf{$\Omega$} com uma descrição discreta;
		
		\item \textbf{Geração de malha:} decompor o interior do domínio em uma malha $\textbf{M}$ de elementos simples e "bem modelados", como caixas ou \textit{simplices} com uma proporção limitada;
		
		\item \textbf{Aproximação numérica:} construir um sistema de equações lineares ou não lineares sobre $\textbf{M}$ para as EDPs governantes;
		
		\item \textbf{Solução numérica:} resolver o sistema de equações e estimar o erro da solução;
		
		\item \textbf{Refinamento adaptativo:} se necessário, refine a malha e repita os passos 5 e 6 sobre as malhas refinadas.
	\end{enumerate}
	
	\hspace{0.5cm} Uma vez que tenhamos gerado uma malha, as equações diferenciais para fluxo, ondas e distribuição de calor são então aproximadas pelas formulações de diferença finita, elemento ou volume. No entanto, nem todas as malhas são igualmente boas numericamente. Os erros de discretização dependem da forma geométrica e do tamanho dos elementos, enquanto a complexidade computacional para encontrar a solução numérica depende do número de elementos na malha e também da qualidade geométrica geral da malha; o objetivo é gerar malhas pequenas e numericamente sólidas.
	
	\hspace{0.5cm} A forma mais simples de uma malha é uma malha estruturada. Existem dois tipos de malhas estruturadas: malhas \textit{geometricamente estruturadas} e \textit{topologicamente estruturadas}. Exemplos de malhas geometricamente estruturadas são grades cartesianas regulares e grades hexagonais uniformes. Nessas malhas, todos os elementos são geometricamente iguais. Uma malha é estruturada topologicamente se sua estrutura topológica for isomórfica à de uma malha estruturada geometricamente. Por exemplo, podemos aplicar uma transformação conforme a uma grade estruturada para gerar uma malha estruturada topologicamente. As grades estruturadas são fáceis de gerar e manipular, o que facilita o uso de estruturas de dados simples para reduzir a complexidade da programação. Além disso, a teoria numérica sobre esses tipos de discretização é bem compreendida. No entanto, o uso de malhas regulares estruturadas limita a aplicabilidade dos métodos numéricos a problemas cujos domínios são simples e cujas funções de solução são suaves.
	
	\hspace{0.5cm} Para problemas com limites geométricos complexos e com soluções que mudam rapidamente, precisamos usar uma malha não estruturada que tenha topologia e espaçamento local variáveis para reduzir o tamanho do problema. Para o exemplo de modelagem de terremotos, precisamos de uma discretização muito mais densa e mais fina perto do centro do terremoto, embora seja desejável não desperdiçar pontos de malha em regiões com baixa atividade. A adaptabilidade de malhas não estruturadas traz novos desafios, especialmente para problemas 3D; a teoria numérica torna-se mais difícil e o projeto algorítmico torna-se mais difícil.
\end{itemize}

\begin{itemize}
	\item \textit{Unstructured Triangular Meshes}
	
	\hspace{0.5cm} A malha mais geral e versátil é uma malha triangular não estruturada na qual cada elemento é um simplex, ou seja, um triângulo em 2D ou um tetraedro em 3D. Em geral, um \textit{k-simplex} é um politopo convexo de $k + 1$ pontos de dimensão $k$. Uma malha triangular é uma triangulação do domínio de entrada (por exemplo, um polígono), juntamente com alguns pontos extras, chamados de \textit{Steiner points}. Uma \textit{triangulação} ou um \textit{complexo simplicial} é uma decomposição de um domínio em uma coleção de \textit{interior disjointed simplices}, de modo que dois \textit{simplices} só podem se cruzar em um simplex de dimensão inferior, ou seja, elementos vizinhos são conformes em seus limites.
	Combinatoriamente, uma triangulação $T$ pode ser expressa como um \textit{Piecewise Linear System} (PLS) de um conjunto $S_{T}$ de \textit{simplices}: se $s$ é um simplex em $S_{T}$ então todas as suas faces de menor dimensão, que também são \textit{simplices}, também pertencem a $S_{T}$ (ver mais em \citealp{teng2000unstructured}).
	
	\hspace{0.5cm} Para aproximar adequadamente uma função contínua, além da condição de que uma malha deve estar de acordo com os limites do domínio e ser suficientemente fina, cada elemento individual da malha deve ser bem modelado. Um critério de forma comum para elementos é a condição de que os ângulos de cada elemento não sejam nem muito pequenos nem muito grandes, ou que a proporção de cada elemento seja limitada.
	
	\hspace{0.5cm} Diversas definições de razão de aspecto têm sido utilizadas na literatura, e se uma delas é limitada por uma constante, todas também são. Por exemplo, em 2D, pode-se usar o menor ângulo de um triângulo para medir sua condição de forma. Em 3D, pode-se usar o menor ângulo diedro de um tetraedro. A seguinte definição de razão de aspecto, popularizada por Mitchell e Vavasis, é definida uniformemente para qualquer dimensão.
\end{itemize}

 \begin{itemize}
	\item \textit{Structured grids}
	
	\hspace{0.5cm} Uma malha cartesiana é facilmente gerada com algumas linhas simples de codificação de computador, em oposição à construção manual demorada de malhas não estruturadas triangulares/tetraédricas.
	Associado a uma grade de fundo cartesiana está um número arbitrário de elementos de origem prescritos pelo usuário nos quais os parâmetros da grade são definidos. Os elementos de origem propagam os parâmetros de espaçamento no campo de forma automática e sistemática.
	Existem dois tipos de elementos: elementos nodais e lineares. As fontes podem ser posicionadas em qualquer lugar no campo, preferencialmente perto das superfícies da geometria e nos limites externos. De um modo geral, a localização de um elemento fonte é escolhida onde uma distribuição bem controlada de pontos de grade é desejada em uma grade de baixa qualidade e em alguns casos afeta severamente o processo de \textit{front advancement} (ver mais em \citealp{pirzadeh1993structured}).
	
\end{itemize}

\begin{itemize}
	\item \textit{Métodos Refinement}
	
	\hspace{0.5cm} A técnica mais popular para geração de conjuntos de pontos e elementos é o Refinamento Iterativo e Adaptativo: Primeiro, uma triangulação inicial é construída. \textit{Steiner points} adicionais são então inseridos no domínio e uma triangulação melhorada é gerada. Mais \textit{Steiner points} são então adicionados para uma melhor triangulação, e assim por diante até que uma malha de qualidade seja obtida (ver mais em \citealp{teng2000unstructured}).
\end{itemize}

\begin{itemize}
	\item \textit{Tomografia de tempos de percurso (Traveltimes tomography)}
	
	\hspace{0.5cm} Esquemas de tomografia baseados em raios usam a aproximação de raios para descrever a propagação da onda através da região de estudo, geralmente chamada de \textit{raytracing}. Vários métodos foram desenvolvidos para realizar o \textit{raytracing}, seguindo diferentes abordagens teóricas. Para tomografia de tempo de percurso, o problema inverso é resolvido por tempos de percurso e caminhos de raios, e o traçado de raios deve ser realizado várias vezes de forma iterativa (\citealp{giroux2013task}).
	
	\hspace{0.5cm} O método \textit{Shortest Path} (\citealp{moser1991shortest}) com nós secundários (\citealp{giroux2013task}) é o algoritmo subjacente implementado no pyGIMLi. Essa abordagem procura o caminho mais rápido através de uma determinada malha da fonte ao receptor. O problema discretizado é um sistema linear de equações que os métodos numéricos podem resolver.
	
	\hspace{0.5cm} De acordo com \cite{ronczka2017electric}, o problema linearizado é dado por $\vv {\Delta d} = G \vv {\Delta m}$, onde a matriz Jacobiana $G$ contém as derivadas parciais ${\partial ti}/{\partial mj}$ e os tempos de deslocamento observados são mantidos em $\vv{d}$. A tomografia de refração sísmica é um problema inverso que pode ser resolvido por uma minimização restrita de suavidade da função de custo dada por
	
	\begin{equation}\label{eq:traveltimes}
	\Phi = \Phi_{d} + \lambda \Phi_{m} = \sum\limits_{i=1}^{N} \left(\frac{d_{i} - f_{i}(m)}{\in _{i}}\right)^{2} + \lambda ||Cm||_{2}^{2}
	\end{equation}
	
	Onde $\Phi_{d} $ é o desajuste dos dados ponderados pelo erro, $\Phi_{m}$ é a rugosidade do modelo e $\lambda$ é o parâmetro de regularização. O tempo de percurso $t$ entre a fonte e o receptor ao longo de um caminho de raio é calculado por
	
	\begin{equation}\label{eq:raio}
	t = \sum\limits_{i=1}^{n} \frac{r_{i}}{v_{i}}
	\end{equation}
	
	Onde $r_{i}$ e ${1}/{v_{i}}$ são o comprimento do caminho (percurso) e a vagarosidade para um segmento $i$, respectivamente. A diferença entre os pontos de dados individuais $d_{i} $ e os correspondentes tempos de percurso teóricos $f_{i}(m)$ é ponderada pelos seus erros individuais $\in _{i}$.
	
	\hspace{0.5cm} Um modelo ponderado funcional $W_{c}$ pode ser usado para incorporar restrições de modelo adicionais na função objeto estendendo a rugosidade $\Phi_{m}$, resultando em
	
	\begin{equation}\label{eq:modelo_ponderado}
	\Phi_{m} = ||W_{c}Cm||_{2}^{2}
	\end{equation}
	
	\hspace{0.5cm} A rugosidade consiste na matriz derivada $C$ aplicada ao modelo $m$. Cada linha em $C$ está associada a um limite, onde a matriz de ponderação $W_{c}$ é uma matriz diagonal onde cada $w_{i}$ representa fatores de penalidade para os diferentes limites das células do modelo.
	
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Estrutura do \emph{Software}}

Todo o código foi escrito em Python (versão 3.8.10) utilizando a distribuição Anaconda (que é uma plataforma de distribuição Python de código aberto) e dessa plataforma usou-se o Visual Studio Code (VS Code) que é um editor de código de código aberto desenvolvido pela Microsoft. Os testes foram realizados em sistemas Windows 10 e Ubuntu 20.04.3 LTS (ambos de 64 bits). O InTTraPy (Invert Travel-Time Python) é dividido em dois módulos: InTTraPy sintético, para realização de estudos de casos sintéticos, e InTTraPy campo, para processar os dados adquiridos em campo. Um fluxo geral de operação sobre como usar o InTTraPy é mostrado na Figura~\ref{fluxo_grama} (página~\pageref{fluxo_grama}).

\begin{description}
	\item[InTTraPy] |\textit{Sintéticos} 
\end{description}

No desenvolvimento do módulo InTTraPy Sintético, começamos importando os pacotes necessários (\textit{matplotlib.pyplot}, \textit{numpy}, \textit{pygimli}, \textit{pygimli.meshtools} e \textit{pygimli.physics.
traveltime}). Em seguida, foi desenvolvida a etapa que permite a construção da geometria de aquisição (que permite definimos as posições dos geofones e um esquema de medição, que consiste em índices de fonte e receptor). Depois usamos o gerenciador \textit{TravelTime} e atribuímos velocidades de onda P. Para isso, criamos um mapa dos marcadores de células de 0 a 3 para velocidades (em m/s) e geramos um vetor de velocidade. Os cálculos de tempo de percurso funcionam em malhas não estruturadas e grades estruturadas. Logo, os dados sintéticos são simulados em uma malha não estruturada e invertidos em uma grade estruturada simples.


Posteriormente, criamos um \textit{DataContainer} (para armazenar, carregar e salvar dados no formato de dados unificado GIMLi. Por padrão, os dados com índices predefinidos como `s', `g' e `t' são \textit{tokens} para números de fontes, geofones e tempo de percurso da onda direta.) vazio e o preenchemos com as posições dos sensores e todos os pares de fontes possíveis para o cenário que o usuário desejar simular.

A simulação direta é realizada com algumas linhas de código. Inicializamos uma instância do \textit{Refraction manager} e chamamos sua função \textit{simulate} com a malha, o esquema e o modelo de vagarosidade ($1/v$). Também adicionamos 0,1\% \textit{relative} e 10 microssegundos de ruído absoluto. Os nós secundários permitem simulações diretas e mais precisas (ver mais em \citealp{giroux2013task}). Logo depois, é criada uma grade estruturada como malha de inversão com a geometria informada pelo usuário. Configuramos também \textit{setRecalcJacobian(False)} para \textit{setRecalcJacobian(True)} para simular a inversão linear.

Por fim, é gerado o modelo e o resultado da inversão um ao lado do outro. Também é gerado um mapa do caminho que os raios percorreram. 

\begin{description}
	\item[InTTraPy] |\textit{Campo} 
\end{description}

Para o desenvolvimento do módulo InTTraPy Campo, 

\begin{figure}[!hbtp]
	\begin{center}
		\includegraphics[scale=0.189]{Figuras/Portela_TCC.png}
	\end{center}
	\caption{Fluxo de operação geral com as etapas usadas em cada módulo para realizar a análise e processamento de dados de tomografia sísmica por tempo de percurso usando o InTTraPy.}
	\label{fluxo_grama}
\end{figure} \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Etapa experimental - Aquisição em local com alvo conhecido}

\blindtext 
%
\blindtext 
%
\blindtext

\begin{comment}
	\begin{itemize}
	
	\item Wavelet
	
	\end{itemize}
\end{comment}

\begin{comment}
\begin{table}[!hbtp]
\caption{Parâmetros utilizados nos modelos sintéticos de duas camadas.}
\centering
\label{parametros_gerais_modelos}
\begin{tabular}{@{}ll@{}}
\toprule
\multicolumn{1}{c}{Parâmetros} & \multicolumn{1}{c}{Valores} \\ \midrule
\rowcolor[HTML]{EFEFEF} 
Tempo de gravação          & 6, 12, 30, 60 e 120 s  \\
Número de fontes           & 100 \\
\rowcolor[HTML]{EFEFEF} 
Distância entre receptores & 1, 2, 4, 8 e 20 m      \\
Wavelet                    & $2^{a}$ Derivada Gaussiana   \\
\rowcolor[HTML]{EFEFEF} 
Frequência máxima          & 30 Hz                  \\
Frequência de pico         & 15 Hz                  \\
\rowcolor[HTML]{EFEFEF} 
Discretização (dx e dz)    & 1 m                    \\
Amostragem (dt)            & 0.009 s                \\ \bottomrule
\end{tabular}
\end{table}
\end{comment}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Resultados e Discussão}
\label{ResultadosDiscussao}

\subsection{Dados sintéticos - Estudos de casos}

\blindtext 
%
\blindtext 
%
\blindtext

\begin{comment}
\begin{table}[!hbtp]
\caption{Velocidades da onda P características de diferentes materiais geológicos. Modificado de \cite{oliveira1998geologia}.}
\centering
\label{tabela_vp}
\begin{tabular}{@{}ll@{}}
\toprule
$V_{p}$ (m/s)                         & Material                                                                                                                                          \\ \midrule
\rowcolor[HTML]{EFEFEF} 
{\color[HTML]{000000} 200 - 400} & {\color[HTML]{000000} Solos, sedimentos inconsolidados}                                                                                           \\
400 - 1400                       & Argilas/areias inconsolidadas                                                                                                                     \\
\rowcolor[HTML]{EFEFEF} 
1400 - 1800                      & \begin{tabular}[c]{@{}l@{}}Areias saturadas, argila compactadas, \\ rochas muito alteradas\end{tabular}                                           \\
1800 - 2400                      & \begin{tabular}[c]{@{}l@{}}Sedimentos consolidados/saturados, \\ rochas ígneas/metamórficas, rochas\\ alteradas, arenitos, folhelhos\end{tabular} \\
\rowcolor[HTML]{EFEFEF} 
2400 - 3700                      & \begin{tabular}[c]{@{}l@{}}Arenitos, folhelhos, rochas ígneas/\\ metamórficas alteradas\end{tabular}                                              \\ \bottomrule
\end{tabular}
\end{table}
\end{comment}



\clearpage 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Dados de campo - Processamento e inversão dos dados sísmicos}

\blindtext 
%
\blindtext 
%
\blindtext

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusões}

\blindtext 
%
\blindtext 
%
\blindtext


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{seg}
\bibliography{Referencias}


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\section{pyGIMLi: Biblioteca \textit{TravelTimeManager} utilizada para o desenvolvimento do \emph{Software}}
\label{apendice_scr}

\begin{lstlisting}[language=Python, caption=Código-fonte para pygimli.physics.traveltime.TravelTimeManager]

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Class for managing first arrival travel time inversions"""
import os
import numpy as np
import matplotlib.pyplot as plt

from matplotlib.collections import LineCollection

import pygimli as pg
from pygimli.frameworks import MeshMethodManager

from pygimli.utils import getSavePath
from . modelling import TravelTimeDijkstraModelling

class TravelTimeManager(MeshMethodManager):
	"""Manager for refraction seismics (traveltime tomography).
	
	TODO Document main members and use default MethodManager interface
	e.g., self.inv, self.fop, self.paraDomain, self.mesh, self.data
	"""
	
	def __init__(self, data=None, **kwargs):
		"""Create an instance of the Traveltime manager.
		
		Parameters
		----------
		data: :gimliapi:`GIMLI::DataContainer` | str
		You can initialize the Manager with data or give them a dataset
		when calling the inversion.
		"""
		self._useFMM = False
		self.secNodes = 2  # default number of secondary nodes for inversion
		
		super(TravelTimeManager, self).__init__(data=data, **kwargs)
		
		self.inv.dataTrans = pg.trans.Trans()
	
	@property
	def velocity(self):
		"""Return velocity vector (the inversion model)."""
		# we can check here if there was an inversion run
		return self.fw.model  # shouldn't it be the inverse?
	
	def createForwardOperator(self, **kwargs):
		"""Create default forward operator for Traveltime modelling.
		
		Your want your Manager use a special forward operator you can add them
		here on default Dijkstra is used.
		"""
		fop = TravelTimeDijkstraModelling(**kwargs)
		return fop
	
	def load(self, fileName):
		"""Load any supported data file."""
		self.data = pg.physics.traveltime.load(fileName)
		return self.data
	
	def createMesh(self, data=None, **kwargs):
		"""Create default inversion mesh.
		
		Inversion mesh for traveltime inversion does not need boundary region.
		"""
		d = data or self.data
		
		if d is None:
		pg.critical('Please provide a data file for mesh generation')
		
		return pg.meshtools.createParaMesh(d.sensors(),
		boundary=0, **kwargs)
	
	def checkData(self, data):
		"""Return data from container."""
		if isinstance(data, pg.DataContainer):
		if not data.haveData('t'):
		pg.critical('DataContainer has no "t" values.')
		return data['t']
	
		return data
	
	def checkError(self, err, dataVals):
		"""Return relative error."""
		if isinstance(err, pg.DataContainer):
		if not err.haveData('err'):
		pg.error('DataContainer has no "err" values. Fallback to 3%')
		return np.ones(err.size()) * 0.03
		return err['err'] / dataVals
		
		return err
	
	def applyMesh(self, mesh, secNodes=None, ignoreRegionManager=False):
		"""Apply mesh, i.e. set mesh in the forward operator class."""
		if secNodes is None:
		secNodes = self.secNodes
		
		self.fop._refineSecNodes = secNodes
		if secNodes > 0:
		if ignoreRegionManager:
		mesh = self.fop.createRefinedFwdMesh(mesh)
		
		self.fop.setMesh(mesh, ignoreRegionManager=ignoreRegionManager)
	
	def simulate(self, mesh, scheme, slowness=None, vel=None, seed=None,
	secNodes=2, noiseLevel=0.0, noiseAbs=0.0, **kwargs):
		"""Simulate traveltime measurements.
		
		Perform the forward task for a given mesh, a slowness distribution (per
		cell) and return data (traveltime) for a measurement scheme.
		
		Parameters
		----------
		mesh : :gimliapi:`GIMLI::Mesh`
		Mesh to calculate for or use the last known mesh.
		scheme: :gimliapi:`GIMLI::DataContainer`
		Data measurement scheme needs 's' for shot and 'g' for geophone
		data token.
		slowness : array(mesh.cellCount()) | array(N, mesh.cellCount())
		Slowness distribution for the given mesh cells can be:
		
		* a single array of len mesh.cellCount()
		* a matrix of N slowness distributions of len mesh.cellCount()
		* a res map as [[marker0, res0], [marker1, res1], ...]
		vel : array(mesh.cellCount()) | array(N, mesh.cellCount())
		Velocity distribution for the given mesh cells.
		Will overwrite given slowness.
		secNodes: int [2]
		Number of refinement nodes to increase accuracy of the forward
		calculation.
		noiseLevel: float [0.0]
		Add relative noise to the simulated data. noiseLevel*100 in %
		noiseAbs: float [0.0]
		Add absolute noise to the simulated data in ms.
		seed: int [None]
		Seed the random generator for the noise.
		
		Keyword Arguments
		-----------------
		returnArray: [False]
		Return only the calculated times.
		verbose: [self.verbose]
		Overwrite verbose level.
		**kwargs
		Additional kwargs ...
		
		Returns
		-------
		t : array(N, data.size()) | DataContainer
		The resulting simulated travel time values.
		Either one column array or matrix in case of slowness matrix.
		"""
		verbose = kwargs.pop('verbose', self.verbose)
		
		fop = self.fop
		fop.data = scheme
		fop.verbose = verbose
		
		if mesh is not None:
		self.applyMesh(mesh, secNodes=secNodes, ignoreRegionManager=True)
		
		if vel is not None:
		slowness = 1/vel
		
		if slowness is None:
		pg.critical("Need some slowness or velocity distribution for"
		" simulation.")
		
		if len(slowness) == self.fop.mesh().cellCount():
		t = fop.response(slowness)
		else:
		print(self.fop.mesh())
		print("slowness: ", slowness)
		pg.critical("Simulate called with wrong slowness array.")
		
		ret = pg.DataContainer(scheme)
		ret.set('t', t)
		
		if noiseLevel > 0 or noiseAbs > 0:
		if not ret.allNonZero('err'):
		ret.set('t', t)
		err = noiseAbs + t * noiseLevel
		ret.set('err', err)
		
		pg.verbose("Absolute error estimates (min:max) {0}:{1}".format(
		min(ret('err')), max(ret('err'))))
		
		t += pg.randn(ret.size(), seed=seed) * ret('err')
		ret.set('t', t)
		
		if kwargs.pop('returnArray', False) is True:
		return t
		
		return ret
		
	def invert(self, data=None, useGradient=True, vTop=500, vBottom=5000,
	secNodes=2, **kwargs):
		"""Invert data.
		
		Parameters
		----------
		data : pg.DataContainer()
		Data container with at least SensorIndieces 's g' and
		data values 't' (traveltime in ms) and 'err' (absolute error in ms)
		useGradient: bool [True]
		Use a gradient like starting model suited for standard flat
		earth cases. [Default]
		For cross tomography geometry you should set this to False for a
		non gradient startind model.
		vTop: float
		Top velocity for gradient stating model.
		vBottom: float
		Bottom velocity for gradient stating model.
		secNodes: int [2]
		Amount of secondary nodes used for ensure accuracy of the forward
		operator.
		
		Keyword Arguments
		-----------------
		** kwargs:
		Inversion related arguments:
		See :py:mod:`pygimli.frameworks.MeshMethodManager.invert`
		"""
		mesh = kwargs.pop('mesh', None)
		
		self.secNodes = secNodes
		
		if 'limits' in kwargs:
		if kwargs['limits'][0] > 1:
		tmp = kwargs['limits'][0]
		kwargs['limits'][0] = 1.0 / kwargs['limits'][1]
		kwargs['limits'][1] = 1.0 / tmp
		pg.verbose('Switching velocity limits to slowness limits.',
		kwargs['limits'])
		
		if useGradient:
		self.fop._useGradient = [vTop, vBottom]
		else:
		self.fop._useGradient = None
		
		slowness = super().invert(data, mesh, **kwargs)
		velocity = 1.0 / slowness
		self.fw.model = velocity
		return velocity
		
	def drawRayPaths(self, ax, model=None, **kwargs):
		"""Draw the the ray paths for model or last model.
		
		If model is not specifies, the last calculated Jacobian is used.
		
		Parameters
		----------
		model : array
		Velocity model for which to calculate and visualize ray paths (the
		default is model for last Jacobian calculation in self.velocity).
		ax : matplotlib.axes object
		To draw the model and the path into.
		**kwargs : type
		Additional arguments passed to LineCollection (alpha, linewidths,
		color, linestyles).
		
		Returns
		-------
		lc : matplotlib.LineCollection
		"""
		if model is not None:
		if self.fop.jacobian().size() == 0 or model != self.model:
		self.fop.createJacobian(1/model)
		else:
		model = self.model
		
		_ = kwargs.setdefault("color", "w")
		_ = kwargs.setdefault("alpha", 0.5)
		_ = kwargs.setdefault("linewidths", 0.8)
		
		shots = self.fop.data.id("s")
		recei = self.fop.data.id("g")
		
		segs = []
		for s, g in zip(shots, recei):
		wi = self.fop.way(s, g)
		points = self.fop._core.mesh().positions(withSecNodes=True)[wi]
		segs.append(np.column_stack((pg.x(points), pg.y(points))))
		
		lc = LineCollection(segs, **kwargs)
		ax.add_collection(lc)
		
		return lc
		
	def showRayPaths(self, model=None, ax=None, 
	**kwargs):
		"""Show the model with ray paths for given model.
		
		If not model specified, the last calculated Jacobian is taken.
		
		Parameters
		----------
		model : array
		Velocity model for which to calculate and visualize ray paths (the
		default is model for last Jacobian calculation in self.velocity).
		ax : matplotlib.axes object
		To draw the model and the path into.
		**kwargs : type
		forward to drawRayPaths
		
		Returns
		-------
		ax : matplotlib.axes object
		cb : matplotlib.colorbar object (only if model is provided)
		
		Examples
		--------
		>>> # No reason to import matplotlib
		>>> import pygimli as pg
		>>> from pygimli.physics import TravelTimeManager
		>>> from pygimli.physics.traveltime import createRAData
		>>>
		>>> x, y = 8, 6
		>>> mesh = pg.createGrid(x, y)
		>>> data = createRAData([(0,0)] + [(x, i) for i in range(y)],
		...                     shotDistance=y+1)
		>>> data.set("t", pg.Vector(data.size(), 1.0))
		>>> tt = TravelTimeManager()
		>>> tt.fop.setData(data)
		>>> tt.applyMesh(mesh, secNodes=10)
		>>> ax, cb = tt.showRayPaths(showMesh=True, diam=0.1)
		"""
		if model is None:
		if self.fop.jacobian().size() == 0:
		self.fop.mesh()  # initialize any meshs .. just to be sure is 1
		model = pg.Vector(self.fop.regionManager().parameterCount(),
		1.0)
		else:
		model = self.model
		
		ax, cbar = self.showModel(ax=ax, model=model,
		showMesh=kwargs.pop('showMesh', None),
		diam=kwargs.pop('diam', None))
		
		self.drawRayPaths(ax, model=model, **kwargs)
		
		return ax, cbar
	
	def rayCoverage(self):
		"""Ray coverage, i.e. summed raypath lengths."""
		return self.fop.jacobian().transMult(
		np.ones(self.fop.jacobian().rows()))
	
	def standardizedCoverage(self):
		"""Standardized coverage vector (0|1) using neighbor info."""
		coverage = self.rayCoverage()
		C = self.fop.constraintsRef()
		return np.sign(np.absolute(C.transMult(C * coverage)))
	
	def showCoverage(self, ax=None, name='coverage', **kwargs):
		"""Show the ray coverage in log-scale."""
		if ax is None:
		fig, ax = plt.subplots()
		
		cov = self.rayCoverage()
		return pg.show(self.fop.paraDomain,
		pg.log10(cov+min(cov[cov > 0])*.5), ax=ax,
		coverage=self.standardizedCoverage(), **kwargs)
	
	def saveResult(self, folder=None, size=(16, 10), verbose=False, **kwargs):
		"""Save the results in a specified (or date-time derived) folder.
		
		Saved items are:
		* Resulting inversion model
		* Velocity vector
		* Coverage vector
		* Standardized coverage vector
		* Mesh (bms and vtk with results)
		
		Args
		----
		path: str[None]
		Path to save into. If not set the name is automatically created
		size: (float, float) (16,10)
		Figure size.
		
		Keyword Args
		------------
		Will be forwarded to showResults
		
		Returns
		-------
		str:
		Name of the result path.
		"""
		subfolder = self.__class__.__name__
		path = getSavePath(folder, subfolder)
		
		if verbose:
		pg.info('Saving refraction data to: {}'.format(path))
		
		np.savetxt(os.path.join(path, 'velocity.vector'),
		self.velocity)
		np.savetxt(os.path.join(path, 'velocity-cov.vector'),
		self.rayCoverage())
		np.savetxt(os.path.join(path, 'velocity-scov.vector'),
		self.standardizedCoverage())
		
		m = pg.Mesh(self.paraDomain)
		
		m['Velocity'] = self.paraModel(self.velocity)
		m['Coverage'] = self.rayCoverage()
		m['S_Coverage'] = self.standardizedCoverage()
		m.exportVTK(os.path.join(path, 'velocity'))
		m.saveBinaryV2(os.path.join(path, 'velocity-pd'))
		self.fop.mesh().save(os.path.join(path, 'velocity-mesh'))
		
		np.savetxt(os.path.join(path, 'chi.txt'), self.inv.chi2History)
		
		fig, ax = plt.subplots()
		self.showResult(ax=ax, cov=self.standardizedCoverage(), **kwargs)
		fig.set_size_inches(size)
		fig.savefig(os.path.join(path, 'velocity.pdf'), bbox_inches='tight')
		pg.plt.close(fig)
		return path

\end{lstlisting}

\end{document}




